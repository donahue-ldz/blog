title: finalize理解
date: 2014-09-28 17:30:28
categories: java
tags: [finalize,内存回收]
---

**Object类声明了protect finalize方法**

>我们都知道程序初始化的重要性，但是通常会忘记清除工作的重要性，我们知道在c++中有构造函数初始化，有相应的析构函数完成收尾清楚工作

在java中，有c++样构造函数却没有其相应的析构函数，但是却有一个和析构函数相似的一个finalize方法，很多人容易混淆他们两个，下面是区别：

1. c++中析构函数在对象声明周期结束时会被调用，数组等new出来时候，delete等函数时候析构会被调用，如果忘记调用这些函数的时候就会造成内存泄露

2. java中的finalize方法在GC进行回收之前在做`第二次标记`的时候会被调用。
如果对象没有覆盖finalize()或者已经被调用了一次之后，将不再调用了，如果需要调用的话会被加入一个称为F-queue队列中，然后由虚拟机去自动开一条低优先权的线程去执行，**但是不一定会等待其去执行完**。
我们知道对于GC什么时候调用，以及什么时候调用对象的finalize方法这些都是不确定的，一般情况下当内存比较充足时候GC不会去时刻调用的
因Gc调用也要消耗资源嘛，对于有些程序而言，有可能某些对象的没有调用GC时候程序已经结束，此时交给**操作系统去回收内存**。

---

所以finalize方法并不总是调用。但是这个方法还是比较有用的，我们知道：
`java的GC之后回收new 出来的对象内存`
`对于有些时候我们使用native方法，如才c/c++时候采取malloc分配的内存此时GC就不能回收了`   
我们也不希望这些内存一直存在，我们可以在finalize方法中去调用native方法的free等函数去试着回收，当finalize方法被调用时候，就象的finalize方法被调用时候，我们可以在里面实现和析构函数相同的功能
但是如果没能呗回收了，最起码被回收的机会由原来的0变成大于0了

就是当对有被调用的时候，就不能同等去看待了
在现实的使用中我们完全可以忘掉这个方法，她所做的事情完全可以有finally模块去完成，不要使用他吧
